\documentclass[a4paper]{article}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{breakurl}
\usepackage{lineno}
\usepackage[a4paper]{geometry} 
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}

\usepackage{fancyhdr}
%The first page setting
\fancypagestyle{plain}
{
  \fancyhf{} % clear current header and footer fields
  \fancyhead[L]
  {
    LINK\"OPING UNIVERSITY\\
    Division of Statistics\\
    Dept. of Computer and Information Science\\
    Feng Li \& Mattias Villani
  }
  \fancyhead[R]{Programming in R}
}
  
%The remaining pages
\pagestyle{fancy}
\fancyhead[RO,LE]{} 
\fancyhead[C]{Programming in R}
\fancyhead[LO,RE]{}
  
\title{D3--Basic programming techniques, debugging and coding style}  
\date{February 27, 2012}

\begin{document}
\maketitle
\hrule
\begin{center}
\textbf{Instructions}
\end{center}
\begin{itemize}
\item You should always try hard to solve the problems yourself. You may
  discuss them with others but any sort of plagiarism is strictly forbidden.  
\item Questions marked with $\heartsuit$ should be answered in your report. All
  other questions need not be in your submitted report. Make extensive use of
  comments (lines starting with the \texttt{\#}-symbol) in your code.
\item Submit your report to \emph{CourseKit} no later than \textbf{Mar 2,
    6:00pm}. 
\end{itemize}
\hrule
  
\section{}
February 29, known as a leap day in the calendar, is a date that occurs
  in most years that are evenly divisible by $4$, such as $2004$, $2008$,
  $2012$ and $2016$. Years that are evenly divisible by $100$ do not contain a
  leap day, with the exception of years that are evenly divisible by $400$,
  which do contain a leap day; thus $1900$ did not contain a leap day while
  $2000$ did.
\begin{enumerate}

\item Write a function called \texttt{isLeapday} to check if a given year has
  February 29 [Hint:  you may need \texttt{?\%\%}.].  

\item Test your function for the following years, 1998, 2000, 2002, 2100.

\item I want to check which year has a leap day for a vector of given
  years. Modify your function to implement this change. 
\end{enumerate}

\section{$\heartsuit$}
The factorial function is formally defined by
\begin{equation*}
  \label{eq:1}
    n!=\prod_{k=1}^n k \! 
\end{equation*}

\begin{enumerate}
\item Write a function \texttt{myFactorial()} with a \texttt{for} loop to
  calculate the factorial for any positive integer input $n$.
\item Test your function with the following numbers $n=$ 1, 10, 100.
\item Write a similar function \texttt{myFactorial2()} using a \texttt{while} loop
  instead and test your function with the following numbers 1, 10, 100 to check
  if you get the same results as before.
\item Write a third factorial function \texttt{myFactorial3()} without loops
  [Hint: use \texttt{prod()} function]
\item Replicate \texttt{myFactorial(150)} for $5000$ times and check how much
  time takes to run it. [Hint: use \texttt{replicate()} and \texttt{system.time()}] 
     
\item Repeat \textbf{2.5} with \texttt{myFactorial2()} and
  \texttt{myFactorial3()}.
\item For the three ways of calculating the factorial, which one do you
  prefer. Discuss the pro and cons. 
\item What will you get if you try \texttt{myFactorial(500)} ?
\item Note that 
\begin{equation*}
  \label{eq:1}
    \log(n!)=\sum_{k=1}^n \log(k) \!.   
\end{equation*}
Modify your \texttt{myFactorial()} and add an extra argument \texttt{log} so that
when \texttt{log = TRUE} the new function returns the logarithm of the factorial and \texttt{log =
  FALSE} return the usual factorial.
\item What do you obtain if you run \texttt{myFactorial(500, log = TRUE)}?
\item Write your final version of the factorial function \texttt{myFactorialNew()}
  without loops and with a log argument.
\end{enumerate}

\section{$\heartsuit$}
The two files \texttt{Apple.csv} and \texttt{Google.csv} contain the daily
historical stock market prices for Apple Inc. and Google Inc. from 2004-08-19
to 2012-02-24 (1889 working days). [\textbf{Note:} Please use the datasets
enclosed in this Lab, not the ones from Lab 1]

\begin{enumerate}
\item Load the datasets as data frames and name them as \texttt{Apple} and \texttt{Google}
  respectively.

\item  Use \texttt{apply()} function to answer these
  questions.  What are the mean values for the open, high, low, and close
  prices in the past 1889 days for Apple Inc? Did you get the same results as
  using \texttt{colMeans()}? How about the standard deviation?

\item Write a function called \texttt{mad()} to calculate the mean absolute
  deviation for a give sequence vector \texttt{x}.  The mean absolute deviation
  is defined as
  \begin{equation*}
    \label{eq:2}
    \operatorname{MAD} = \frac{1}{n} \sum_{i=1}^n{|x_i-\bar x|} 
  \end{equation*}
  where $\bar x$ is the mean value of the input vector \texttt{x}. [Hint: you
  may need \texttt{abs()} function.]

\item Use \texttt{apply()} with your \texttt{mad()} function to apply to the
  columns of your \texttt{Apple} data.

\item Use \texttt{as.list()} to convert your \texttt{Apple} and \texttt{Google}
  into lists and name them \texttt{AppleLst} and \texttt{GoogleLst}.

\item Write a new function called \texttt{extremeVal()} to obtain the extreme
  values of a given vector \texttt{x}. A value $x_i$ is called a extreme value
  from $x$ if $x_i> 700$ or $x_i < 100$.

\item Use \texttt{lapply()} function to calculate the extreme values for the
  open, high, low, and close prices for Google Inc.

% \item Write a function \texttt{maxdif()} that calculates the difference of the
%   maximum value of two input argument vectors \texttt{x} and \texttt{y},
%   i.e. $\max(x) - \max(y)$.

% \item Use \texttt{mapply()} to calculate the maximum differences for the open,
%   high, low, and close prices respectively of the two companies. Play with the
%   argument \texttt{SIMPLIFY} to see the final output type.


% \item You feel like to organize the two companies data into one object. So you
%   merge the two lists into a new list named \texttt{StockData},

% \begin{verbatim}
% StockData <- list(Apple = AppleLst, Google = GoogleLst)
% \end{verbatim}
% Note that your \texttt{StockData} is a list with entires as lists.

% Use \texttt{rapply()} function to calculate the minimum values for open, high,
% low, and close prices for the two companies. Also play with the argument
% \texttt{how} to see the final output type.


\end{enumerate}

 
\section{}
The normal distribution $\mathcal{N}(\mu, \sigma^2)$ which has probability density function
\begin{equation*}
  \label{eq:3}
    f(x, \mu,\sigma^2) = \frac{1}{\sqrt{2\pi}\ \sigma\ } \exp{\left(-\frac {(x-\mu)^2}{2\sigma^2} \right)}.   
\end{equation*}
The probability of observing the data sample, $x_1,\ldots,x_n$, considered as a function of
the parameters $\mu$ and $\sigma^2$ is called the likelihood function. A common method of
estimating these parameters is to find values of  $\mu$ and $\sigma^2$ such that the
likelihood function is maximized. This makes sense: the best values of the parameters are
those that make the observed data as probable as possible. It is common to maximize the
likelihood function on the log-scale (it gives the same parameter estimates, but is
usually simpler to handle). The logarithm of the likelihood-function is called the
log-likelihood function. If we assume independent observations, the log-likelihood is here
of the form
\begin{equation*}
  \label{eq:4}
    \mathcal{L}(\mathbf{x}, \mu,\sigma^2) = \log f( x_{1}, \mu,
    \sigma^2) + \log f( x_{2}, \mu, \sigma^2) + ... + \log f( x_{n}, \mu, \sigma^2).
\end{equation*}
where $\mathbf{x} = (x_1,x_2,...x_n)$ is the vector with $n$ data observations. Here is Karl's code for the likelihood function,

\begin{linenumbers}
\begin{verbatim}
aa <- function(x, mu, sigma)
{y <- NULL
for(i in 1:length(x)){
a <- sqrt(2*pi)*sigma
y[i] <- 1/a*exp(-(x[i]-mu)^2/(2*sigma^2))}
a <- NULL
for(j in 1:length(y))  a <- a + log(y[j]) 
a}
\end{verbatim}
\end{linenumbers}

\begin{enumerate}
\item Comment on his coding style and point out at least \textbf{five} places
  that he can improve in terms of naming, readability, commenting, indentation,
  executing efficiency(vectorization), potential over/under-flow.

\item Write your version of code for the log likelihood function. Remember to
  avoid the issues raised in Karl's code. Try to vectorize the code and to avoid unnecessary calculations.

\end{enumerate}

\section{$\heartsuit$}
\begin{enumerate}

\item Jim wanted to write a function to check if a scalar (single number, not a vector) \texttt{a}
is present as one the elements of a vector \texttt{b}, so he wrote a function
\texttt{isIn()} 

\begin{verbatim}
isIn <- function(a, b) { 
  j <- 1
  while (j <= length(b)) {
    if(a == b[j]) {
      out <- TRUE}
    else {
      out <- FALSE}
    j <- j + 1
  }
  return(out)
}
\end{verbatim}

Test the function with \texttt{isIn(3, 1:3)} and \texttt{isIn(3, 1:5)}. Does
the function do what it is supposed to do?

\item Insert \texttt{browser()} in the code at the proper location and check
  what has happened inside the loop. You may also want to try other debugging
  tools as well [Hint \texttt{?debug} for more information on how to work
  within the debugging environment].

\item Remove the bug with minimal changes of the code.

\item Jim wanted to extend his function allowing \texttt{a} to be a vector as
  well. His purpose was to check which elements in vector \texttt{a} are
  available in \texttt{b}. Here is his yet another attempt.

\newpage
\begin{verbatim}
isIn <- function(a, b)
  { 
    out <- rep(NA, length(a))    
    j <- 0
    while(j <= length(b))
      {
        j <- j + 1
        for ( i in 1:length(a))
          {out[i] <- (a[i] == b[j])}
      }
    return(out)
  }
\end{verbatim}

  Try this function with \texttt{a <- 1:5, b <- 3:9}. Did you get the desired
  results this time?

\item Save the original function into a file \texttt{myRscript.R} and
  insert \texttt{browser()} at a proper location in your function. Append your
  debugging code e.g 

\begin{verbatim}
a <- 1:5 
b <- 3:9
isIn(a, b)
\end{verbatim}
  at the end of your file. The use command \texttt{source("myRscript.R")} at
  the console to load the function and get into the debugging environment to
  debug the code. [Hint: again you may need \texttt{getwd()} and
  \texttt{setwd()} to make everything smoothly.]

\item Remove the bug with minimal changes in the code.
\item Compare your results with the results from \texttt{\%in\%} to check if
  your modification is right.
\end{enumerate}


\end{document}
